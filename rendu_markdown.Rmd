---
title: "DirectionsAPI"
author: "Arthur Artaud"
date: "3/18/2021"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```




## Librabries

We first install the libraries needed for general operations


```{r}
if (!require('dplyr')){
  install.packages('dplyr')
}
library('dplyr')
if (!require('sf')){
  install.packages('sf')
}
library('sf')
```

## Rural points

We make 500 random points of origin and 500 points of destinations within the shp of the departement of Creuse (a rural zone in France) that we got from the [ADMIN-EXPRESS-COG Ã©dition 2020](https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html#admin-express)

```{r}
creuse <- st_read("data/Creuse.shp", quiet=TRUE)
plot(st_geometry(creuse))
#creation of points
if (!exists("pt_creuse") & !exists("pt_creuse_b")){
  pt_creuse <- st_sample(x = creuse, size = 500)
  pt_creuse_b <- st_sample(x = creuse, size= 500)
}
#display of the points
plot(st_geometry(pt_creuse), add=T, col="red", pch = 20)
plot(st_geometry(pt_creuse_b), add=T, col="blue", pch = 20)
```

## Urban points

Same thing for the city of Lyon

```{r}
lyon <- st_read("data/Lyon.shp", quiet=TRUE)
plot(st_geometry(lyon))
#creation of points
if (!exists("pt_lyon") & !exists("pt_lyon_b")){
  pt_lyon <- st_sample(x = lyon, size = 500)
  pt_lyon_b <- st_sample(x = lyon, size= 500)
}
#display of the points
plot(st_geometry(pt_lyon), add=T, col="red", pch = 20)
plot(st_geometry(pt_lyon_b), add=T, col="blue", pch = 20)
```

## Suburban points

For the suburban we took the city of Paris, we did a buffer of 5km to move away from the very dense close suburb.

Then we did another buffer of 30km and made a rectangle of the southwest side and took the intersection between this and the buffer minus the first buffer.
Then we did the points.

```{r}
paris <- st_read("data/Paris.shp", quiet=TRUE)
#creation of the buffers
paris_b5 <- st_buffer(paris, 5000)
paris_b30_5 <- st_buffer(paris_b5, 30000)
plot(st_geometry(paris_b30_5), lwd = 3, border = "blue")
plot(st_geometry(paris_b5), add = T, lwd=2, border = "red")
plot(st_geometry(paris), add = T)
#creation of the rectangle
m <- rbind(c(652083,6862280), c(696084,6862280), c(696084,6822480), 
           c(652083,6822480), c(652083,6862280))
p <- st_sf(st_sfc(st_polygon(list(m))), crs = st_crs(paris))
plot(p, border="green", lwd=2, add=T)
#intersection
paris_z <- st_intersection(x = p, y = paris_b30_5)
paris_f <- st_difference(x = paris_z, y = paris_b5)
plot(st_geometry(paris_f), add=T)
#creation of points
if(!exists("pt_paris") & !exists("pt_paris_b")){
  pt_paris <- st_sample(x = paris_f, size = 500)
  pt_paris_b <- st_sample(x = paris_f, size= 500)
}
#display of the points
plot(st_geometry(pt_paris_b), add=T, col="blue", pch = 20)
plot(st_geometry(pt_paris), add=T, col="red", pch = 20)
```


## First API : OSRM

The first API we're gonna use is OpenSourceRoutingMachine wich is a open source project that use openstreetmap data.

We need the package osrm to use it in R and to talk with the api (with the default server with limitations or your own)

```{r}
if (!require('osrm')){
  install.packages('osrm')
}
library('osrm')
```

Then we transform the points into sf data to give them directly to the osrm api.

```{r}
#for creuse
x_c <- st_sf(pt_creuse)
y_c <- st_sf(pt_creuse_b)
x_c$id <- 1:nrow(x_c)
y_c$id <- 1:nrow(y_c)
#for lyon
x_l <- st_sf(pt_lyon)
y_l <- st_sf(pt_lyon_b)
x_l$id <- 1:nrow(x_l)
y_l$id <- 1:nrow(y_l)
#for paris suburb
x_p <- st_sf(pt_paris)
y_p <- st_sf(pt_paris_b)
x_p$id <- 1:nrow(x_p)
y_p$id <- 1:nrow(y_p)
```

To input the points we call the osrmRoute() as many times as there is points (500 times)

And we stock the routes into list

```{r}
#if(!exists("route_list_creuse")){
#  route_list_creuse <- list()
#  for (i in 1:nrow(x_c)) {
#  route_list_creuse[[i]] <- osrmRoute(
#      src = x_c[i,],
#      dst = y_c[i,],
#      overview = "full",
#      returnclass = "sf")
#    }
#}


#if(!exists("route_list_lyon")){
#  route_list_lyon <- list()
#  for (i in 1:nrow(x_l)) {
#    route_list_lyon[[i]] <- osrmRoute(
#      src = x_l[i,],
#      dst = y_l[i,],
#      overview = "full",
#      returnclass = "sf")
#    }
#}

#if(!exists("route_list_paris")){
#  route_list_paris <- list()
#  for (i in 1:nrow(x_p)) {
#    route_list_paris[[i]] <- osrmRoute(
#      src = x_p[i,],
#      dst = y_p[i,],
#      overview = "full",
#      returnclass = "sf")
#    }
#}
route_list_creuse <- readRDS(file = "data/route_list_creuse.rds")
route_list_lyon <- readRDS(file = "data/route_list_lyon.rds")
route_list_paris <- readRDS(file = "data/route_list_paris.rds")
```

We can bind_rows() them if we want to make an sf dataframe for displaying them trough tmap viewing tool qtm(),

that we can make interactive by putting the "view" mode

```{r}
if (!require('tmap')){
  install.packages('tmap')
}
library('tmap')

sf_route_creuse <- bind_rows(route_list_creuse)
sf_route_lyon <- bind_rows(route_list_lyon)
sf_route_paris <- bind_rows(route_list_paris)

#tmap_mode("view")
qtm(sf_route_creuse)
qtm(sf_route_lyon)
qtm(sf_route_paris)
```

There should be no error here so we are gonna use the coordinates that osrm transformed from the original points to the nearest road, and we are gonna put them in the international crs wgs84 because we were using the french lambert93 until now.

These coordinates are gonna be usefull to have less error from the others api because they have more errors otherwise.

```{r}
coord_osrm_creuse <- list()
for (i in 1:length(route_list_creuse)) {
  coordinates_wgs <- st_coordinates(st_transform(route_list_creuse[[i]], 4326))
  l <- nrow(coordinates_wgs)
  coord_osrm_creuse[[i]] <- list(c(coordinates_wgs[1,1],coordinates_wgs[1,2]),c(coordinates_wgs[l,1], coordinates_wgs[l,2]))
}
coord_osrm_lyon <- list()
for (i in 1:length(route_list_lyon)) {
  coordinates_wgs <- st_coordinates(st_transform(route_list_lyon[[i]], 4326))
  l <- nrow(coordinates_wgs)
  coord_osrm_lyon[[i]] <- list(c(coordinates_wgs[1,1],coordinates_wgs[1,2]),c(coordinates_wgs[l,1], coordinates_wgs[l,2]))
}
coord_osrm_paris <- list()
for (i in 1:length(route_list_paris)) {
  coordinates_wgs <- st_coordinates(st_transform(route_list_paris[[i]], 4326))
  l <- nrow(coordinates_wgs)
  coord_osrm_paris[[i]] <- list(c(coordinates_wgs[1,1],coordinates_wgs[1,2]),c(coordinates_wgs[l,1], coordinates_wgs[l,2]))
}
```

## Second API GraphHopper

GraphHopper is a german open source project used by Deutsche Bahn and Flixbus. You will need java 8 installed for this one and the next.

For Graphhopper we are gonna need to go into the command line for setting up a new instance with an osm.pbf file that you can find at [geofabrik](https://download.geofabrik.de/europe/france.html) and a [jar](https://graphhopper.com/public/releases/graphhopper-web-2.3.jar) file and a [config](https://raw.githubusercontent.com/graphhopper/graphhopper/1.0/config-example.yml) file

for this new command line you have to type (being into the file you put all your files):

java -Ddw.graphhopper.datareader.file=<your-file>.osm.pbf -jar graphhopper-web-2.3.jar server config-example.yml

you can also have a docker instance.

We are gonna need the GraphHopper r library
```{r}
if (!require('graphhopper')){
  install.packages('graphhopper')
}
library('graphhopper')
```

then we have to connect with the API inside Rstudio

```{r}
#if(!exists("route_gh_creuse")){
#  API_URL <- "http://localhost:8989"
#  gh_set_api_url(API_URL)
#  info <- gh_get_info()
#}
```

We also have to give the coordinates to GraphHopper into a lat long format so the osrm coordinates need to be inverted

```{r}
coord_inv_creuse <- list()
for (i in 1:length(coord_osrm_creuse)) {
  start_point <- c(coord_osrm_creuse[[i]][[1]][2],coord_osrm_creuse[[i]][[1]][1])
  end_point <- c(coord_osrm_creuse[[i]][[2]][2],coord_osrm_creuse[[i]][[2]][1])
  coord_inv_creuse[[i]] <- list(start_point, end_point)
}

coord_inv_lyon <- list()
for (i in 1:length(coord_osrm_lyon)) {
  start_point <- c(coord_osrm_lyon[[i]][[1]][2],coord_osrm_lyon[[i]][[1]][1])
  end_point <- c(coord_osrm_lyon[[i]][[2]][2],coord_osrm_lyon[[i]][[2]][1])
  coord_inv_lyon[[i]] <- list(start_point, end_point)
}

coord_inv_paris <- list()
for (i in 1:length(coord_osrm_paris)) {
  start_point <- c(coord_osrm_paris[[i]][[1]][2],coord_osrm_paris[[i]][[1]][1])
  end_point <- c(coord_osrm_paris[[i]][[2]][2],coord_osrm_paris[[i]][[2]][1])
  coord_inv_paris[[i]] <- list(start_point, end_point)
}
```

Then we can run GraphHopper with the 500 points of origin and destination

```{r}
#if(!exists("route_gh_creuse")){
#  route_gh_creuse <- list()
#  for (i in 1:length(coord_inv_creuse)) {
#    (route_gh_creuse[[i]] <- gh_get_route(coord_inv_creuse[[i]]) %>% gh_as_sf())
#    }
#}

#if(!exists("route_gh_lyon")){
#  route_gh_lyon <- list()
#  for (i in 1:length(coord_inv_lyon)) {
#    (route_gh_lyon[[i]] <- gh_get_route(coord_inv_lyon[[i]]) %>% gh_as_sf())
#    }
#}

#if(!exists("route_gh_paris")){
#  route_gh_paris <- list()
#  for (i in 1:length(coord_inv_paris)) {
#    (route_gh_paris[[i]] <- gh_get_route(coord_inv_paris[[i]]) %>% gh_as_sf())
#    }
#}
route_gh_creuse <- readRDS(file = "data/route_gh_creuse.rds")
route_gh_lyon <- readRDS(file = "data/route_gh_lyon.rds")
route_gh_paris <- readRDS(file = "data/route_gh_idf.rds")
```

To visualize them we can do the same as for the osrm routes:

```{r}
r_gh_creuse <- bind_rows(route_gh_creuse)
r_gh_lyon <- bind_rows(route_gh_lyon)
r_gh_paris <- bind_rows(route_gh_paris)

qtm(r_gh_creuse)
qtm(r_gh_lyon)
qtm(r_gh_paris)
```

## Third API: OpenTripPlanner

OTP is the oldest open source routing project and it originated from several agencies in the US.

I advise to download the dev version of the r package because its the only way that worked for me.

```{r}
if (!require('remotes')){
  install.packages('remotes')
}
library('remotes')
if (!require('opentripplanner')){
  remotes::install_github('ropensci/opentripplanner')
}
library('opentripplanner')
if (!require('RcppSimdJson')){
  install.packages('RcppSimdJson')
}
library('RcppSimdJson')
```

Then we build the graph with the osm.pbf file that you put (that dont need to be rebuilt after) and we setup the local instance.

The osm.pbf files need to be put into the OTP/graphs/<name-of-the-osm.pbf-directory> with a name that you will call for building and setting the instances (here creuse, lyon and paris).

You also want to build and set them each one at a time for performance reasons and because otherwise you need to specify a new port for the users.
 
```{r}
#setting up the path

path_data <- file.path("C:/Users/Public", "OTP")
dir.create(path_data)
path_otp <- otp_dl_jar(path_data, cache = FALSE)

#building the graphs :

#log_creuse <- otp_build_graph(otp = path_otp, dir = path_data, router = 'creuse', memory = 4294)
#log_lyon <- otp_build_graph(otp = path_otp, dir = path_data, router = 'lyon', memory = 4294)
#log_paris <- otp_build_graph(otp = path_otp, dir = path_data, router = 'paris', memory = 4294)

#setting up the local instance :

#log_creuse2 <- otp_setup(otp = path_otp, dir =  path_data, router = 'creuse')
#log_lyon2 <- otp_setup(otp = path_otp, dir =  path_data, router = 'lyon')
#log_paris2 <- otp_setup(otp = path_otp, dir =  path_data, router = 'paris')

#connect to the routers :

#otpcon <- otp_connect(router = 'creuse')
#otpcon <- otp_connect(router = 'lyon')
#otpcon <- otp_connect(router = 'paris')
```
 
 We put the coordinates of the osrm results back in sf format to process them all at once
 
```{r}
#creuse
point_sf_creuse <- list()
for (i in 1:length(coord_osrm_creuse)) {
  point_sf_creuse[[i]] <- st_sf(st_sfc(st_point(coord_osrm_creuse[[i]][[1]]),  crs = 4326))
}
point_sf_creuseb <- list()
for (i in 1:length(coord_osrm_creuse)) {
  point_sf_creuseb[[i]] <- st_sf(st_sfc(st_point(coord_osrm_creuse[[i]][[2]]),  crs = 4326))
}
point_sf_creuse <- bind_rows(point_sf_creuse)
point_sf_creuseb <- bind_rows(point_sf_creuseb)
#lyon
point_sf_lyon <- list()
for (i in 1:length(coord_osrm_lyon)) {
  point_sf_lyon[[i]] <- st_sf(st_sfc(st_point(coord_osrm_lyon[[i]][[1]]),  crs = 4326))
}
point_sf_lyonb <- list()
for (i in 1:length(coord_osrm_lyon)) {
  point_sf_lyonb[[i]] <- st_sf(st_sfc(st_point(coord_osrm_lyon[[i]][[2]]),  crs = 4326))
}
point_sf_lyon <- bind_rows(point_sf_lyon)
point_sf_lyonb <- bind_rows(point_sf_lyonb)
#idf
point_sf_paris <- list()
for (i in 1:length(coord_osrm_paris)) {
  point_sf_paris[[i]] <- st_sf(st_sfc(st_point(coord_osrm_paris[[i]][[1]]),  crs = 4326))
}
point_sf_parisb <- list()
for (i in 1:length(coord_osrm_paris)) {
  point_sf_paris[[i]] <- st_sf(st_sfc(st_point(coord_osrm_paris[[i]][[2]]),  crs = 4326))
}
point_sf_paris <- bind_rows(point_sf_paris)
point_sf_parisb <- bind_rows(point_sf_parisb)
```
 
 
 Then we process the itineraries from the instance (you can process faster with ncores = 2 or more in fonction of the cores of your processor -1) and we display them
 
```{r}
#route_otp_creuse <- otp_plan(otpcon,
#                            point_sf_creuse,
#                             point_sf_creuseb)

#route_otp_lyon <- otp_plan(otpcon,
#                           point_sf_lyon,
#                           point_sf_lyonb)

#route_otp_idf <- otp_plan(otpcon,
#                          point_sf_idf,
#                          point_sf_idfb)
route_otp_creuse <- readRDS(file = "data/route_otp_creuse.rds")
route_otp_lyon <- readRDS(file = "data/route_otp_lyon.rds")
route_otp_paris <- readRDS(file = "data/route_otp_idf.rds")
qtm(route_otp_creuse)
qtm(route_otp_lyon)
qtm(route_otp_paris)
```
 
 and for stopping the otp java program you do this:
 
```{r}
otp_stop()
```
 